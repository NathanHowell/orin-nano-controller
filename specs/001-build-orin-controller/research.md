# Phase 0 Research

## Rust Toolchain Selection

Decision: Adopt the stable `rustc 1.90.0 (1159e78c4 2025-09-14)` toolchain with edition 2024 support; no nightly features required.  
Rationale: This release is already installed, covers edition 2024 (needed by the workspace), and supports Embassy 0.4/0.9 crates without unstable gates, keeping CI/tooling simple.  
Alternatives considered: Nightly toolchain (rejected—no required unstable features identified yet); older stables such as 1.80–1.89 (rejected—would forfeit edition 2024 defaults and recent embedded fixes).

## Embassy Crate & Timer Configuration

Decision: Keep the existing Embassy stack (`embassy-executor 0.9.1`, `embassy-stm32 0.4.0`, `embassy-time 0.5.0`) and add `embassy-usb 0.3.0` with the `cdc-acm` class, `defmt`, and `unstable-packet-serial-multiplexer` features disabled; continue using the `time-driver-tim1` feature as the lowest-footprint general-purpose timer on STM32G0.  
Rationale: Embassy 0.4.x for STM32 pairs with 0.3.x USB crates, giving us the newest async APIs and FS device support; TIM1 is already wired in the feature set, consumes minimal additional peripherals compared with 32-bit TIM2/LPTIM, and satisfies the user's "cheapest timer" guidance.  
Alternatives considered: Switching to LPTIM1 driver (rejected—Embassy lacks a mature low-power driver on G0B1 and would cost extra setup); downgrading to Embassy 0.2/0.3 (rejected—would undo workspace alignment and require API rewrites); enabling nightly-only Embassy features (rejected—unneeded).

## USB↔UART Bridge Architecture

Decision: Implement a bidirectional bridge using a second `embassy_usb::class::cdc_acm::CdcAcmClass` interface on the USB side, an `embassy_stm32::usart::BufferedUart` for the TTL port, and two fixed-capacity `embassy_sync::channel::Channel` queues to decouple producer/consumer tasks (USB RX→UART TX, UART RX→USB TX); orchestrate with dedicated async tasks spawned by the Embassy executor and avoid polling by awaiting on channel receive/send futures.  
Rationale: Embassy channels provide bounded buffers meeting the fixed-size queue requirement; separate tasks simplify flow control (one per direction plus USB event driver); using a dedicated CDC interface keeps bridge traffic isolated from the REPL while integrating cleanly with the composite device descriptors; both CdcAcmClass and BufferedUart integrate with Embassy without busy loops, leveraging interrupts/DMA, and the RX path doubles as the trigger for releasing `recovery now` once console bytes arrive.  
Alternatives considered: Polling loops that read/write directly between endpoints (rejected—violates "do not poll"); using `embassy_sync::pipe` (rejected—bounded channels already suit small UART frames and simplify backpressure); employing a custom ring buffer (rejected—reinventing channel semantics).

## Command Grammar & REPL Strategy

Decision: Replace the JSON API with a lightweight REPL running over the CDC channel, backed by a declarative command grammar plus a custom line editor that supports tab-completion on the MCU. Syntax is tokenized with `logos` (no_std capable) and parsed using `winnow` combinators layered over the grammar description so the parser logic stays separate from the command catalog.  
Rationale: Both `logos` and `winnow` operate in `no_std` with optional `alloc`, fitting the STM32 footprint while letting us describe tokens/productions in data rather than hard-coded branches. A bespoke `SerialLineEditor` can handle backspace, cursor echo, and Tab expansion without dragging in heavyweight (std-only) readline crates; completions are generated by walking the grammar tree, so new commands update both parsing and completion automatically.  
Alternatives considered: 
- `ragel`-style state machines (rejected—toolchain integration is awkward for Rust `no_std`, requires host-side code generation).  
- `nom` with custom macros (rejected—`nom` is heavier, and existing derived parsers still intertwine grammar with code).  
- Host-side CLI (rejected—we need the MCU to remain usable over a plain serial terminal without extra tooling).  
- Using a general-purpose readline crate such as `rustyline`/`reedline` (rejected—`std`-only, memory-heavy for embedded).

## Test Harness Strategy

Decision: Factor logic (sequence state machines, parsers, voltage guard conditions) into `#[cfg(test)]`-friendly modules that compile for `thumbv6m-none-eabi` and `x86_64-unknown-linux-gnu`, run unit tests with `cargo test` on the host using the built-in test runner, and reserve `defmt-test`/probe-run smoke tests for later integration evidence.  
Rationale: Host-side unit tests execute quickly without hardware, fulfilling the mandate to test parsers/logic; keeping code `no_std` with optional `alloc` gating ensures embedded compatibility; defmt-test smoke tests can be layered once hardware harness is ready.  
Alternatives considered: Relying solely on hardware-in-loop tests (rejected—slower feedback, harder automation); skipping tests because of embedded constraints (rejected—violates requirement for unit tests on logic); adopting nightly-only `generic-tests` (rejected—unnecessary).
