# Phase 0 Research

## Rust Toolchain Selection

Decision: Adopt the stable `rustc 1.91.0` toolchain with edition 2024 support; no nightly features required.  
Rationale: This release is already installed, covers edition 2024 (needed by the workspace), and supports Embassy 0.4/0.9 crates without unstable gates, keeping CI/tooling simple.  
Alternatives considered: Nightly toolchain (rejected—no required unstable features identified yet); older stables such as 1.80–1.90 (rejected—would forfeit edition 2024 defaults and recent embedded fixes).

## Embassy Crate & Timer Configuration

Decision: Keep the existing Embassy stack (`embassy-executor 0.9.1`, `embassy-stm32 0.4.0`, `embassy-time 0.5.0`) and add `embassy-usb 0.3.0` with the `cdc-acm` class, `defmt`, and `unstable-packet-serial-multiplexer` features disabled; continue using the `time-driver-tim1` feature as the lowest-footprint general-purpose timer on STM32G0.  
Rationale: Embassy 0.4.x for STM32 pairs with 0.3.x USB crates, giving us the newest async APIs and FS device support; TIM1 is already wired in the feature set, consumes minimal additional peripherals compared with 32-bit TIM2/LPTIM, and satisfies the user's "cheapest timer" guidance.  
Alternatives considered: Switching to LPTIM1 driver (rejected—Embassy lacks a mature low-power driver on G0B1 and would cost extra setup); downgrading to Embassy 0.2/0.3 (rejected—would undo workspace alignment and require API rewrites); enabling nightly-only Embassy features (rejected—unneeded).

## USB↔UART Bridge Architecture

Decision: Implement a bidirectional bridge using a second `embassy_usb::class::cdc_acm::CdcAcmClass` interface on the USB side, an `embassy_stm32::usart::BufferedUart` for the TTL port, and two fixed-capacity `embassy_sync::channel::Channel` queues to decouple producer/consumer tasks (USB RX→UART TX, UART RX→USB TX); orchestrate with dedicated async tasks spawned by the Embassy executor and avoid polling by awaiting on channel receive/send futures.  
Rationale: Embassy channels provide bounded buffers meeting the fixed-size queue requirement; separate tasks simplify flow control (one per direction plus USB event driver); using a dedicated CDC interface keeps bridge traffic isolated from the REPL while integrating cleanly with the composite device descriptors; both CdcAcmClass and BufferedUart integrate with Embassy without busy loops, leveraging interrupts/DMA, and the RX path doubles as the trigger for releasing `recovery now` once console bytes arrive.  
Alternatives considered: Polling loops that read/write directly between endpoints (rejected—violates "do not poll"); using `embassy_sync::pipe` (rejected—bounded channels already suit small UART frames and simplify backpressure); employing a custom ring buffer (rejected—reinventing channel semantics).

## Command Grammar & REPL Strategy

Decision: Replace the JSON API with a lightweight REPL running over the CDC channel, backed by a declarative command grammar plus a custom line editor that supports tab-completion on the MCU. Syntax is tokenized with `regal` (no_std capable) and parsed using `winnow` combinators layered over the grammar description so the parser logic stays separate from the command catalog.  
Rationale: Both `regal` and `winnow` operate in `no_std` with optional `alloc`, fitting the STM32 footprint while letting us describe tokens/productions in data rather than hard-coded branches. A bespoke `SerialLineEditor` can handle backspace, cursor echo, and Tab expansion without dragging in heavyweight (std-only) readline crates; completions are generated by walking the grammar tree, so new commands update both parsing and completion automatically.  
Alternatives considered: 
- `ragel`-style state machines (rejected—toolchain integration is awkward for Rust `no_std`, requires host-side code generation).  
- `nom` with custom macros (rejected—`nom` is heavier, and existing derived parsers still intertwine grammar with code).  
- Host-side CLI (rejected—we need the MCU to remain usable over a plain serial terminal without extra tooling).  
- Using a general-purpose readline crate such as `rustyline`/`reedline` (rejected—`std`-only, memory-heavy for embedded).

## Test Harness Strategy

Decision: Factor logic (sequence state machines, parsers, voltage guard conditions) into `#[cfg(test)]`-friendly modules that compile for `thumbv6m-none-eabi` and `x86_64-unknown-linux-gnu`, run unit tests with `cargo test` on the host using the built-in test runner, and reserve `defmt-test`/probe-run smoke tests for later integration evidence.  
Rationale: Host-side unit tests execute quickly without hardware, fulfilling the mandate to test parsers/logic; keeping code `no_std` with optional `alloc` gating ensures embedded compatibility; defmt-test smoke tests can be layered once hardware harness is ready.  
Alternatives considered: Relying solely on hardware-in-loop tests (rejected—slower feedback, harder automation); skipping tests because of embedded constraints (rejected—violates requirement for unit tests on logic); adopting nightly-only `generic-tests` (rejected—unnecessary).

## VREFINT Brown-Out Detection Design

Decision: Drive brown-out detection from the STM32G0B1 internal reference (`VREFINT`) so the firmware can classify the 3.3 V rail without external dividers. The `controller-core` power monitor abstraction will expose calibrated millivolt readings and hysteresis so both firmware and emulator can consume consistent semantics.  
Rationale: `VREFINT` is trimmed at production and accessible on every package; sampling it with ADC1 channel 10 avoids the board-to-board variance that comes with using the Jetson LED divider. A calibrated reading gives us deterministic retry gating inside the shared orchestrator and lets us reuse the logic in host tests.  
Alternatives considered: Relying on the existing LED divider (rejected—indirect proxy, laggy under PWM dimming); monitoring external VDD sense pins (rejected—requires BOM change); using PVD threshold interrupts (rejected—coarse granularity, no telemetry of actual droop).

### Calibration & Constants

- `VREFINT_CAL` resides at `0x1FFF_75AA` (16-bit unsigned) and reflects a 12-bit ADC conversion performed at exactly 3.0 V during factory trim.  
- Runtime VDDA is derived with `vdda_mv = (3000 * VREFINT_CAL) / sample`, where `sample` is the most recent ADC1 channel-10 conversion.  
- Brown-out entry threshold: 3050 mV (≈7.5% below nominal 3.3 V).  
- Brown-out clear threshold: 3150 mV, yielding 100 mV of hysteresis to avoid chatter once the supply rebounds.  
- Sampling period defaults to 5 ms; power must remain above the clear threshold for 25 ms (`stable_holdoff`) before the orchestrator resumes sequences.

### Sampling Procedure

1. Enable the internal reference for the ADC by setting `SYSCFG_CFGR3.VREFEN` (via Embassy's `enable_vrefint()` helper once added) and waiting the datasheet-specified 10 µs stabilization delay.  
2. Configure ADC1 single-ended channel 10 with `sample_time = 64.5 cycles` to satisfy the minimum acquisition time for the 3.0 kΩ source impedance of `VREFINT`.  
3. Trigger a conversion on each poll; discard the first sample after enabling the channel to allow the sampling capacitor to settle.  
4. Treat a conversion result of `0` as invalid and surface `PowerStatus::Unknown`, ensuring the orchestrator does not mistakenly classify power as healthy.  
5. Store the latest `PowerSample` (timestamp + millivolt reading) so telemetry can report both brown-out events and stabilization.

### Failure Handling & Telemetry

- If `VREFINT_CAL` reads as `0xFFFF` or `0x0000`, fall back to `PowerStatus::Unknown` and emit a telemetry warning; this keeps retries disabled while highlighting the calibration fault.  
- Each brown-out transition produces telemetry showing `enter_threshold_mv`, `exit_threshold_mv`, and the sampled value so bench evidence can justify retries.  
- Retries remain bounded by the existing orchestrator policy; the new monitor only influences when the FSM leaves the `Error` state.  
- Emulator builds will provide a deterministic stub that injects scripted millivolt values, enabling unit tests for the hysteresis logic described above.
